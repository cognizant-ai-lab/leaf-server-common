version: "1.0"

steps:

    clone-repo:
        type: git-clone
        title: "Clone ${{CF_REPO_NAME}} repo"
        repo: "${{CF_REPO_OWNER}}/${{CF_REPO_NAME}}"
        git: github
        revision: "${{CF_REVISION}}"

    prepare_for_build:
        description: "Do any common preparation for tests"
        type: "freestyle"
        image: alpine:3.13.1
        working_directory: ${{CF_VOLUME_PATH}}/${{CF_REPO_NAME}}
        commands:
            # Set up some variables

            # It's our experience the the CF_VOLUME can leak between builds
            # Attempt to do some isolation.
            - export TEMP_DIR_OUTSIDE_CONTAINER=${{CF_VOLUME_PATH}}/tmp/${{CF_BUILD_ID}}
            - mkdir -p ${TEMP_DIR_OUTSIDE_CONTAINER}

            - export APP_HOME=/home/${{CF_REPO_OWNER}}
            - export APP_SOURCE=${APP_HOME}/${{CF_REPO_NAME}}

            # cf_export these variables so these vars can be used in later build steps
            - cf_export TEMP_DIR_OUTSIDE_CONTAINER APP_HOME APP_SOURCE

    create-temp-git-creds-from-vault:
        title: "Get ephemeral GitHub creds"
        description: "Get temporary git credentials from vault server.
                      Create credential for use in docker secret with_creds_requirements"
        type: "freestyle"
        image: "vault:1.12.0"
        working_directory: ${{CF_VOLUME_PATH}}/${{CF_REPO_NAME}}

        # Disable all caching for this step to ensure the requirements file
        # is always up to date. This step is very quick so the time hit
        # is minimal.
        # disable docker local cache
        no_cache: true
        # disable codefresh additional caching mechanisms
        no_cf_cache: true

        commands:
            # Specifically use the temp directory outside the container we want to build
            # so as not to accidentally copy sensitive credentials inside of it.
            - export WITH_CREDS_REQUIREMENTS=${{TEMP_DIR_OUTSIDE_CONTAINER}}/with_creds_requirements.txt
            - cp requirements.txt ${WITH_CREDS_REQUIREMENTS}
            - cf_export WITH_CREDS_REQUIREMENTS

            # Login into Vault only once
            - vault login -address=${{VAULT}} -method=github token=${{VAULT_LOGIN}} | grep -Ev "(token |token_accessor)"

            # Get the ephemeral token for public repos
            - EPHEMERAL_TOKEN=$(vault read -address=${{VAULT}} -field=token /github-secrets/token/repo-read)
            - EPHEMERAL_LEAF_SOURCE_CREDENTIALS="x-access-token:${EPHEMERAL_TOKEN}"
            - sed -i "s/\${LEAF_SOURCE_CREDENTIALS}/${EPHEMERAL_LEAF_SOURCE_CREDENTIALS}/g" ${WITH_CREDS_REQUIREMENTS}

    repo_build:
        title: "Building Docker image for ${{CF_REPO_NAME}}"
        type: "build"
        image_name: "leaf/${{CF_REPO_NAME}}"
        tag: ${{CF_BRANCH_TAG_NORMALIZED}}-${{CF_SHORT_REVISION}}
        working_directory: ${{CF_VOLUME_PATH}}/${{CF_REPO_NAME}}
        dockerfile: "build_scripts/Dockerfile"
        buildkit: true
        # Docker BuildKit has different output. This progress plain allows
        # us to see the "old" style output which is useful.
        progress: "plain"
        # The src refers to our secret file on the host system. Within the
        # dockerfile we refer to the secret by id. By not providing a dst
        # the file ends up at the docker default of /run/secrets/<id>
        secrets:
            - id=with_creds_requirements,src=${{WITH_CREDS_REQUIREMENTS}}
        build_arguments:
            - REPO=${{CF_REPO_NAME}}
            - USERNAME=${{CF_REPO_OWNER}}
            - APP_HOME=${{APP_HOME}}
            - APP_SOURCE=${{APP_SOURCE}}

    run_all_tests:
        type: parallel
        steps:
            run_pylint:
                title: Run pylint
                # Use the image created by the repo_build step above
                # See: https://codefresh.io/docs/docs/codefresh-yaml/variables/
                image: ${{repo_build}}
                description: "Run Pylint"
                # Specifically run in the APP_SOURCE directory inside the container,
                # *not* in the CF_VOLUME as we had erroneously done before.
                working_directory: ${{APP_SOURCE}}
                # Allow the pipeline to continue if this step fails
                fail_fast: false
                commands:
                    - pip3 freeze
                    - build_scripts/run_pylint.sh

            run_flake8:
                title: Run flake8
                # Use the image created by the repo_build step above
                # See: https://codefresh.io/docs/docs/codefresh-yaml/variables/
                image: ${{repo_build}}
                description: "Run Flake8"
                # Specifically run in the APP_SOURCE directory inside the container,
                # *not* in the CF_VOLUME as we had erroneously done before.
                working_directory: ${{APP_SOURCE}}
                # Allow the pipeline to continue if this step fails
                fail_fast: false
                commands:
                    - pip3 freeze
                    # See repo ~/.flake8 file for settings
                    - flake8

            run_shellcheck:
                title: Run Static Analysis on Shell Scripts
                description: "Run shellcheck tool on our shell scripts"
                type: "freestyle"
                # Use the image created by the repo_build step above
                # See: https://codefresh.io/docs/docs/codefresh-yaml/variables/
                image: ${{repo_build}}
                # Specifically run in the APP_SOURCE directory inside the container,
                # *not* in the CF_VOLUME as we had erroneously done before.
                working_directory: ${{APP_SOURCE}}
                fail_fast: false
                commands:
                    - ./build_scripts/run_shellcheck.sh

            run_unit_tests:
                title: Run unit tests
                # Use the image created by the repo_build step above
                # See: https://codefresh.io/docs/docs/codefresh-yaml/variables/
                image: ${{repo_build}}
                description: Run unit tests (nosetests)
                # Specifically run in the APP_SOURCE directory inside the container,
                # *not* in the CF_VOLUME as we had erroneously done before.
                working_directory: ${{APP_SOURCE}}
                fail_fast: false
                commands:
                    - pip3 freeze
                    - nosetests -v --nocapture --with-ignore-docstrings --with-timer --timer-top-n 10 --timer-ok 30s --timer-warning 60s

    clean_up:
        description: "Clean up after ourselves"
        type: "freestyle"
        image: alpine:3.13.1
        working_directory: ${{CF_VOLUME_PATH}}/${{CF_REPO_NAME}}
        commands:
            # Clean up anything senstive we do not want to leak between builds
            - rm -rf ${{TEMP_DIR_OUTSIDE_CONTAINER}}

    all_test_status:
        title: Check For Failed Tests
        description: "Handle any fail cases that may have occurred"
        image: alpine:3.13.1
        commands:
            - exit 1
        when:
            condition:
                any:
                    static_test_fail:
                        steps.run_pylint.result == "failure" ||
                        steps.run_flake8.result == "failure" ||
                        steps.run_shellcheck.result == "failure" ||
                        steps.run_unit_tests == "failure" ||
                        steps.run_all_tests == "failure"
